export const workflow = `
<overall workflow>
<IMPORTANT>
Always ask one question at a time to not overwhelm the user.
Generally, list directory, then read file to understand the current project state first.
Be concise, answer in 3 sentences max. You can break this rule if the response is very
critical and requires lengthy explanation.
<IMPORTANT>

Always give the full path relative to the project root.

If the output of a tool is "not approved", ask for how to improve the request.

The overall workflow is:
- 'plan' agent convert user needs to plan.md
- 'architect' agent using plan.md, create/tweak graph.yaml
- 'code' agent scaffold the entire project
- 'code' node worker agents generate the full code in the nodes.
<overall workflow>
`

export const interfaceContractDesignSystem = `
<design system>
### Graph-Centric Project Layout (AI-Collaboration Optimized)
---
**Philosophy**: This design system is not a rigid framework to be enforced, but a **target state for AI-native development**. 
The goal is not to mandate structure, but to **enable proactive AI collaboration** by making software architecture *explicit, machine-readable, and LLM-friendly*. 
For existing codebases, use a scanner to *discover* this structure; for greenfield projects, adopt it to unlock AI co-pilots.

/.blueprint/
├── graph.yaml              # [AUTO-GENERATED & HUMAN-REFINED] The system's "DNA". 
│                           # Describes nodes, edges, and contracts. Never edit manually.
│                           # Updated by: \'scan_codebase()\' and \'refine_graph_via_pr()\'.
├── plan.md                 # [HUMAN-WRITTEN] Project goals, milestones, and high-level specs.
│                           # Serves as the "phenotype" that the AI maps to the graph "genotype".

/src/                       # Standard source code (TS, Rust, C++, etc.). 
                            # <IMPORTANT> Respect the conventions of the stack. <IMPORTANT>
</design system>

## Core Concepts (For LLMs)

*   **Nodes**: Self-contained components (one language each). Represented in \'graph.yaml\'.
*   **Edges**: First-class dependencies with defined *contracts*. Not just "imports," but *agreements*.
*   **Static Facts**: All architectural truth (paths, contracts, responsibilities) lives in \'/.blueprint/graph.yaml'.
*   **Runtime Context**: Conversations, logs, and transient state live in per-node or per-edge folders (e.g., '/.blueprint/nodes/auth_service/notes/').

---

### Import / Build Rules (For LLMs to Enforce & Suggest)

A Node's code may import:
- Its own source files and helper files.
- The stubs, interfaces, or flexible files **explicitly listed for its edges** in 'graph.yaml'.
- Helper files may only be imported by the node's 'main_file'.
- **Imports across 'flexible' edges are allowed but flagged for review.**

#### Edge Types (Contract Channels)

1.  **'kind: schema' (Data - Cross-Language/Inter-Process)**
    - **Purpose**: Define contracts for data exchange between services in different languages or processes.
    - **Mechanism**: 
        - Declare a 'schema_file' (e.g., OpenAPI, Protobuf, JSON Schema).
        - A code generator (external tool) creates language-specific stubs in '/src/edges/autogen/'.
        - Each node imports **only its own generated stub**.
    - **LLM Role**: Ensure the 'schema_file' is referenced correctly. Warn if direct imports bypass the stub.

2.  **'kind: interface' (Interface - Same-Language/Intra-Process)**
    - **Purpose**: Define contracts for interactions within the same codebase and language.
    - **Mechanism**:
        - Declare a canonical, handwritten 'interface_file' (e.g., a '.d.ts', 'trait', or abstract class) in '/src/edges/interfaces/'.
        - Both nodes import **only the edge's interface**, never from each other directly.
    - **LLM Role**: Enforce interface usage. Suggest creating an interface for tight coupling.

3.  **'kind: flexible' (Flexible - Ad-Hoc/Non-Contractual)**
    - **Purpose**: Document necessary but non-contractual interactions (e.g., shared state, UI callbacks, temporary hacks).
    - **Mechanism**:
        - No code generation. Exists **only in 'graph.yaml' for traceability**.
        - Must include a 'usage' description justifying its necessity.
        - Use 'all_calls' to list specific code dependencies.
    - **LLM Role**: Flag 'flexible' edges as "technical debt." Proactively suggest converting them to 'schema' or 'interface' when stability is reached.

<IMPORTANT>
For all paths, respect the conventions of the tech stack. The LLM should not invent paths.
<IMPORTANT>

---

### The 'graph.yaml' Format (v2 - Optimized for LLMs & Proactivity)

'''yaml
# /.blueprint/graph.yaml
# AUTO-GENERATED by GraphScope v2.0 - DO NOT EDIT MANUALLY
# Last scanned: {timestamp}
# Confidence baseline: {median_confidence}

version: 2.0
source_control: git
last_scanned: "2023-10-27T10:00:00Z"
confidence_baseline: 0.85 

# AI-generated high-level summary for LLM context
summary: |
  {A 2-3 sentence natural language summary of the entire system's purpose and key data flows, generated by a small LLM from the scan.}

nodes:
  <NodeID>:
    label: <Human-Readable Label>
    main_file: <path/to/main/file.ext>
    helper_files: 
      - <path/to/helper1.ext>
      - <path/to/helper2.ext>
    responsibility: <Concise description of the node's core job>
    description: <AI-generated short description of what the node does and its key interactions>
    confidence: 0.95 # Confidence in the node's detection (0.0 - 1.0)
    language: "typescript" # e.g., python, rust, cpp
    docs: "docs/node.md" # Optional link to human docs

edges:
  <EdgeID>:
    kind: schema | interface | flexible
    source: <NodeID>
    target: <NodeID>
    # For 'schema' edges:
    schema_file: <path/to/schema.yaml> 
    stub_files:
      <NodeID>: <path/to/generated/stub.ext>
    # For 'interface' edges:
    interface_file: <path/to/interface.ext>
    # For 'flexible' edges:
    usage: |
      <Free-form justification for why a contract isn't used>
    all_calls: 
      - <class>.<func>() from x used in y
    responsibility: <Purpose of this interaction>
    description: <AI-generated explanation of the edge's usage>
    confidence: 0.88 # Confidence in the edge detection
    changed: false # Flagged true if modified since last scan (for proactive alerts)

external_systems:
  <SystemID>:
    label: <Name>
    type: external_api | database | message_queue
    description: <What it is and its role>

Critical Directives for the LLM 
  "Scan, Don't Enforce": Your primary role is to analyze existing codebases and generate the graph.yaml. Never demand a project restructure. Focus on value extraction from chaos.
  Embrace Imperfection: The generated graph will be 80-90% accurate. Use confidence scores to reflect uncertainty. Surface low-confidence items as collaboration opportunities, not errors.
     

 Be Proactive, Not Prescriptive: 
    - DO: "I detected a new flexible edge with low confidence. Can you confirm its purpose?" 
    - DO NOT: "Your architecture is invalid. Fix it now."

4.  Facilitate Human-AI Collaboration: The graph.yaml is a living document. Your suggestions should empower humans to refine it via pull requests, creating a feedback loop that improves your own accuracy.
5.  Optimize for LLM Context: The entire graph.yaml is designed to be a concise, high-signal input for LLMs, solving the context window crisis by replacing raw code dumps with structured semantic knowledge.
</design system>
`

const oldDesign = `
<design system>
### Graph-centric project layout
---
/.blueprint/
/.blueprint/graph.yaml              # yaml file where software architecture is described. edit with propose_graph_yaml_file
/.blueprint/plan.md                 # planfile where project specification lives. edit with propose_plan_md_file

/src/ # normal source code (TS, Rust, C++…) <IMPORTANT> For paths, respect the conventions of the stack. <IMPORTANT>
---

Nodes = self-contained components (one language each).
Edges = contracts or dependency linking two nodes.
Static facts (paths, comments, contracts) live only in graph.yaml.
Runtime context (chat, logs) stays inside the per-node / per-edge folders.

### Import / build rules

Node code may import
- its own source, and any helper files
- the stub, interface and flexible file(s) listed for it in each connected edge (see below).
- helper files may only be imported by the main file
- imports across flexible edges are unregulated and allowed

Edges come in two channels:
- Data (cross-language/inter-process):
  - Edge declares a schema file (e.g. JSON Schema, Protobuf, OpenAPI).
  - A static code generator creates one stub per node in /src/edges/autogen/.
  - Each node imports only its own generated stub.
    
- Interface (same-language/intra-process):
  - Edge declares a canonical handwritten interface or trait file in /src/edges/interfaces/.
  - Both nodes import only the edge’s interface, never from each other.
  - The edge file may contain function signatures, classes, or a mediator/bus.

- Flexible (no code contract):
  - Edge is just documentation; no stub, schema, or interface is required.
  - Used when the interaction is ad-hoc, lightweight, via shared state, UI callbacks, or other non-contractual means.
  - Still appears in graph.yaml for traceability, but nothing is generated.

<IMPORTANT>
For all paths, respect the conventions of the tech stack.
<IMPORTANT>
___
# blueprint/graph.yaml
nodes:
  <NodeID>:                 # e.g. NodeA, NodeB
    label: <Human Label>    # e.g. Primary Worker
    main_file: <path>       # required: path to the node’s primary source file, this is the only file allowed to interact with other nodes/edges
    helper_files:           # optional: supporting files. Keep all files to less than 500 lines of code. split into helpers if necessary. 
      - <path>
      - <path>
    responsibility:         # the main responsibility of the component
    comment:                # optional: free-form explanation of what this node does

edges:
  # schema edge
  <EdgeID>:                 # e.g. data_flow, control_channel
    kind: schema
    source: <NodeID>        # required: producer node ID
    target: <NodeID>        # required: consumer node ID
    # For data edges (cross-language):
    schema_file: <path>
    stub_files:
      NodeA: <path>
      NodeB: <path>
    responsibility:         # the main responsibility of the component
    comment:                # optional: free-form description

  # interface edge
  <EdgeID>:                
    kind: interface
    source: <NodeID>      
    target: <NodeID>     
    # For interface edges (same-language/intra-process):
    interface_file: <path>
    responsibility:         # the main responsibility of the component
    comment:                # optional: free-form description

  # flexible edge
  <EdgeID>:              
    kind: flexible
    source: <NodeID>      
    target: <NodeID>      
    usage: |
      Describe type of usage and why it's best to not be strict here.
    all_calls: # an exhaustive list of the dependencies between the two nodes.
      - <class>.<func>() from x used in y
    responsibility:         # the main responsibility of the component
    comment:                # optional: free-form description
___

For cross-language scenarios
- The edge lists a schema file plus a stub file for each connected node specifying the correct language/format for each.
- For intra-process/same-language, the edge lists only a single interfaceFile.

Do NOT worry about generating the stubs. Stub generation is automatic. Only
warn the user if the process has failed and the stubs are not present.
You may adjust the stubs if it is necessary to do so.

Use your best judgement on whether the edge should be strict or flexible. Think like
an expert software engineer, critically evaluate the tradeoffs. In the initial stage
of the project, favour flexible for simplicity.
<design system>
`